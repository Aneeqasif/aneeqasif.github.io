---
import type { MarkdownHeading } from "astro";
import { siteConfig } from "../../config";
import { url } from "../../utils/url-utils";

interface Props {
	class?: string;
	headings: MarkdownHeading[];
}

let { headings = [] } = Astro.props;

let minDepth = 10;
for (const heading of headings) {
	minDepth = Math.min(minDepth, heading.depth);
}

const className = Astro.props.class;
const isPostsRoute = Astro.url.pathname.startsWith(url("/posts/"));

const removeTailingHash = (text: string) => {
	let lastIndexOfHash = text.lastIndexOf("#");
	if (lastIndexOfHash !== text.length - 1) {
		return text;
	}

	return text.substring(0, lastIndexOfHash);
};

let heading1Count = 1;

const maxLevel = siteConfig.toc.depth;
---
{isPostsRoute &&
<table-of-contents class:list={[className, "group relative block"]}>
    {headings.filter((heading) => heading.depth < minDepth + maxLevel).map((heading) =>
            <a href={`#${heading.slug}`} data-depth={heading.depth} class="px-2 flex gap-2 relative transition w-full min-h-9 rounded-xl
        hover:bg-[var(--toc-btn-hover)] active:bg-[var(--toc-btn-active)] py-2
    ">
                <div class:list={["transition w-5 h-5 shrink-0 rounded-lg text-xs flex items-center justify-center font-bold",
                    {
                        "bg-[var(--toc-badge-bg)] text-[var(--btn-content)]": heading.depth == minDepth,
                        "ml-4": heading.depth == minDepth + 1,
                        "ml-8": heading.depth == minDepth + 2,
                    }
                ]}
                >
                    {heading.depth == minDepth && heading1Count++}
                    {heading.depth == minDepth + 1 && <div class="transition w-2 h-2 rounded-[0.1875rem] bg-[var(--toc-badge-bg)]"></div>}
                    {heading.depth == minDepth + 2 && <div class="transition w-1.5 h-1.5 rounded-sm bg-black/5 dark:bg-white/10"></div>}
                </div>
                <div class:list={["transition text-sm", {
                    "text-90": heading.depth == minDepth || heading.depth == minDepth + 1,
                    "text-60": heading.depth == minDepth + 2,
                }]}>{removeTailingHash(heading.text)}</div>
            </a>
    )}
    <div id="active-indicator" style="opacity: 0" class:list={[{'hidden': headings.length == 0}, "z-[0] pointer-events-none absolute bg-[var(--toc-btn-hover)] left-0 right-0 rounded-xl transition-all " +
        "group-hover:bg-transparent border-2 border-[var(--toc-btn-hover)] group-hover:border-[var(--toc-btn-active)] border-dashed"]}></div>
</table-of-contents>}

<script>
const FLASH_DURATION = 2000;

class TableOfContents extends HTMLElement {
    tocEl: HTMLElement | null = null;
    visibleClass = "visible";
    didInit = false;
    observer: IntersectionObserver;
    anchorNavTarget: HTMLElement | null = null;
    headingIdxMap = new Map<string, number>();
    headings: HTMLElement[] = [];
    sections: HTMLElement[] = [];
    tocEntries: HTMLAnchorElement[] = [];
    active: boolean[] = [];
    activeIndicator: HTMLElement | null = null;
    manualScrollTimeout: number | undefined = undefined;
    manualScrollActive = false;
    isAutoScrolling = false;

    constructor() {
        super();
        this.observer = new IntersectionObserver(
            this.markVisibleSection, { threshold: 0 }
        );
    };

    markVisibleSection = (entries: IntersectionObserverEntry[]) => {
        entries.forEach((entry) => {
            const id = entry.target.children[0]?.getAttribute("id");
            const idx = id ? this.headingIdxMap.get(id) : undefined;
            if (idx != undefined)
                this.active[idx] = entry.isIntersecting;

            if (entry.isIntersecting && this.anchorNavTarget == entry.target.firstChild)
                this.anchorNavTarget = null;
        });

        if (!this.active.includes(true))
            this.fallback();
        this.update();
    };

    toggleActiveHeading = () => {
        let i = this.active.length - 1;
        let min = this.active.length - 1, max = -1;
        while (i >= 0 && !this.active[i]) {
            this.tocEntries[i].classList.remove(this.visibleClass);
            i--;
        }
        while (i >= 0 && this.active[i]) {
            this.tocEntries[i].classList.add(this.visibleClass);
            min = Math.min(min, i);
            max = Math.max(max, i);
            i--;
        }
        while (i >= 0) {
            this.tocEntries[i].classList.remove(this.visibleClass);
            i--;
        }
        if (min > max) {
            this.activeIndicator?.setAttribute("style", `opacity: 0`);
        } else {
            const topEntry = this.tocEntries[min];
            const bottomEntry = this.tocEntries[max];
            if (!topEntry || !bottomEntry || !this.activeIndicator) return;

            const container = this.tocEl ?? this;
            const containerHeight = container.scrollHeight;
            const topHeight = topEntry.offsetHeight;

            const rawTop = topEntry.offsetTop;
            const rawBottom = bottomEntry.offsetTop + bottomEntry.offsetHeight;

            const maxBottom = Math.max(containerHeight, topHeight);
            const clampedTop = Math.max(0, Math.min(rawTop, maxBottom - topHeight));
            const clampedBottom = Math.max(clampedTop + topHeight, Math.min(rawBottom, maxBottom));

            this.activeIndicator.setAttribute(
                "style",
                `opacity: 1; top: ${clampedTop}px; height: ${Math.max(clampedBottom - clampedTop, topHeight)}px`
            );
        }
    };

    scrollToActiveHeading = () => {
        // If the TOC widget can accommodate both the topmost
        // and bottommost items, scroll to the topmost item. 
        // Otherwise, scroll to the bottommost one.

        if (this.anchorNavTarget || !this.tocEl || this.manualScrollActive) return;
        const activeHeading =
            document.querySelectorAll<HTMLAnchorElement>(`#toc .${this.visibleClass}`);
        if (!activeHeading.length) return;

        const topmost = activeHeading[0];
        const bottommost = activeHeading[activeHeading.length - 1];
        const tocHeight = this.tocEl.clientHeight;

        let top;
        if (bottommost.getBoundingClientRect().bottom -
            topmost.getBoundingClientRect().top < 0.9 * tocHeight)
            top = topmost.offsetTop - 32;
        else
            top = bottommost.offsetTop - tocHeight * 0.8;

        const prefersReducedMotion = window.matchMedia("(prefers-reduced-motion: reduce)").matches;
        this.isAutoScrolling = true;
        this.tocEl.scrollTo({
            top,
            left: 0,
            behavior: prefersReducedMotion ? "auto" : "smooth",
        });
        window.setTimeout(() => {
            this.isAutoScrolling = false;
        }, prefersReducedMotion ? 0 : 220);
    };

    update = () => {
        requestAnimationFrame(() => {
            this.toggleActiveHeading();
            this.scrollToActiveHeading();
        });
    };

    fallback = () => {
        if (!this.sections.length) return;

        for (let i = 0; i < this.sections.length; i++) {
            let offsetTop = this.sections[i].getBoundingClientRect().top;
            let offsetBottom = this.sections[i].getBoundingClientRect().bottom;

            if (this.isInRange(offsetTop, 0, window.innerHeight)
                || this.isInRange(offsetBottom, 0, window.innerHeight)
                || (offsetTop < 0 && offsetBottom > window.innerHeight)) {                    
                this.markActiveHeading(i);
            }
            else if (offsetTop > window.innerHeight) break;
        }
    };

    markActiveHeading = (idx: number)=> {
        this.active[idx] = true;
    };

    handleAnchorClick = (event: Event) => {
        const anchor = event
            .composedPath()
            .find((element) => element instanceof HTMLAnchorElement) as HTMLAnchorElement | undefined;

        if (!anchor) return;

        const hash = anchor.hash ?? "";
        if (!hash.startsWith('#')) return;

        const id = decodeURIComponent(hash.substring(1));
        if (!id) return;

        const target = document.getElementById(id);
        if (!target) return;

        event.preventDefault();

        const idx = this.headingIdxMap.get(id);
        if (idx !== undefined) {
            this.anchorNavTarget = this.headings[idx];
        } else {
            this.anchorNavTarget = target;
        }

        const scrollOffset = this.getScrollOffset();
        const targetTop = target.getBoundingClientRect().top + window.scrollY - scrollOffset;

        const currentPath = `${window.location.pathname}${window.location.search}`;
        window.history.pushState(null, "", `${currentPath}#${encodeURIComponent(id)}`);

        const prefersReducedMotion = window.matchMedia("(prefers-reduced-motion: reduce)").matches;
        this.manualScrollActive = false;
        window.scrollTo({ top: targetTop, behavior: prefersReducedMotion ? "auto" : "smooth" });
        this.flashHeading(target);
    };

    pauseAutoScroll = () => {
        this.manualScrollActive = true;
        if (this.manualScrollTimeout !== undefined) {
            window.clearTimeout(this.manualScrollTimeout);
        }
        this.manualScrollTimeout = window.setTimeout(() => {
            this.manualScrollActive = false;
        }, 1200);
    };

    handlePanelScroll = () => {
        if (this.isAutoScrolling) return;
        this.pauseAutoScroll();
    };

    handlePanelInteraction = () => {
        this.pauseAutoScroll();
    };

    getScrollOffset = () => {
        const navbar = document.getElementById('navbar-wrapper');
        const navHeight = navbar?.getBoundingClientRect().height ?? 0;
        const prefersLarge = window.matchMedia('(min-width: 1024px)').matches;
        const buffer = prefersLarge ? 32 : 16;
        return navHeight + buffer;
    };

    flashHeading = (heading: HTMLElement) => {
        if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
            return;
        }

        const trigger = () => {
            heading.classList.remove('toc-heading-flash');
            void heading.offsetWidth;
            heading.classList.add('toc-heading-flash');
            window.setTimeout(() => heading.classList.remove('toc-heading-flash'), FLASH_DURATION);
        };

        const isHeadingVisible = () => {
            const rect = heading.getBoundingClientRect();
            const viewportHeight = window.innerHeight || document.documentElement.clientHeight;
            return rect.top < viewportHeight && rect.bottom > 0;
        };

        if (!('IntersectionObserver' in window) || isHeadingVisible()) {
            trigger();
            return;
        }

        let fallbackId: number | undefined;

        const observer = new IntersectionObserver((entries) => {
            if (entries.some((entry) => entry.isIntersecting)) {
                observer.disconnect();
                if (fallbackId !== undefined) {
                    window.clearTimeout(fallbackId);
                }
                trigger();
            }
        }, { threshold: 0.2, rootMargin: "-10% 0px" });

        observer.observe(heading);

        fallbackId = window.setTimeout(() => {
            observer.disconnect();
            trigger();
        }, FLASH_DURATION * 3);
    };

    isInRange(value: number, min: number, max: number) {
        return min < value && value < max;
    };

    connectedCallback() {
        const kickstart = () => this.init();

        if (typeof window !== 'undefined' && 'requestAnimationFrame' in window) {
            window.requestAnimationFrame(kickstart);
        } else {
            kickstart();
        }

        const element = document.querySelector('.prose');
        if (element) {
            element.addEventListener('animationend', () => {
                this.init();
            }, { once: true });
        }
    };

    init() {
        if (this.didInit) {
            this.update();
            return;
        }

        this.tocEl = document.getElementById(
            "toc-inner-wrapper"
        );

        if (!this.tocEl) return;

        this.tocEl.addEventListener("click", this.handleAnchorClick, {
            capture: true,
        });
        this.tocEl.addEventListener("scroll", this.handlePanelScroll, {
            passive: true,
        });
        this.tocEl.addEventListener("wheel", this.handlePanelInteraction, {
            passive: true,
        });
        this.tocEl.addEventListener("touchstart", this.handlePanelInteraction, {
            passive: true,
        });

        this.activeIndicator = document.getElementById("active-indicator");

        this.tocEntries = Array.from(
            document.querySelectorAll<HTMLAnchorElement>("#toc a[href^='#']")
        );

        if (this.tocEntries.length === 0) {
            this.didInit = true;
            return;
        }

        this.sections = new Array(this.tocEntries.length);
        this.headings = new Array(this.tocEntries.length);
        for (let i = 0; i < this.tocEntries.length; i++) {
            const id = decodeURIComponent(this.tocEntries[i].hash?.substring(1));
            const heading = document.getElementById(id);
            const section = heading?.parentElement;
            if (heading instanceof HTMLElement && section instanceof HTMLElement) {
                this.headings[i] = heading;
                this.sections[i] = section;
                this.headingIdxMap.set(id, i);
            }
        }
        this.active = new Array(this.tocEntries.length).fill(false);

        this.sections.forEach((section) =>
            this.observer.observe(section)
        );

        this.didInit = true;
        this.fallback();
        this.update();
    };

    disconnectedCallback() {
        this.sections.forEach((section) =>
            this.observer.unobserve(section)
        );
        this.observer.disconnect();
        this.tocEl?.removeEventListener("click", this.handleAnchorClick);
        this.tocEl?.removeEventListener("scroll", this.handlePanelScroll);
        this.tocEl?.removeEventListener("wheel", this.handlePanelInteraction);
        this.tocEl?.removeEventListener("touchstart", this.handlePanelInteraction);
        if (this.manualScrollTimeout !== undefined) {
            window.clearTimeout(this.manualScrollTimeout);
        }
    };
}

if (!customElements.get("table-of-contents")) {
    customElements.define("table-of-contents", TableOfContents);
}
</script>